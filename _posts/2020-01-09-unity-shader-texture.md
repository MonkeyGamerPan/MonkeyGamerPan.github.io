---
layout: post
title: "Unity 纹理"
featured-img: shane-rounce-205187
categories: [unity, address]
---



## 纹理（UV）

​	纹理最初的目的就是使用一张图片来控制模型的外观。使用纹理映 射（texture mapping）技术，我们可以把一张图“黏”在模型表面，逐纹 素（texel）（纹素的名字是为了和像素进行区分）地控制模型的颜色。

​	在美术人员建模的时候，**通常会在建模软件中利用纹理展开技术把 纹理映射坐标（texture-mapping coordinates）存储在每个顶点上**。**纹理映射坐标定义了该顶点在纹理中对应的2D坐标**。通常，这些坐标使 用一个二维变量(u, v)来表示，其中u是横向坐标，而v是纵向坐标。因 此，纹理映射坐标也被称为UV坐标。

​	**尽管纹理的大小可以是多种多样的，例如可以是256×256或者 1024×1024，但顶点UV坐标的范围通常都被归一化到[0, 1]范围内。需要 注意的是，纹理采样时使用的纹理坐标不一定是在[0, 1]范围内。实际 上，这种不在[0, 1]范围内的纹理坐标有时会非常有用。与之关系紧密的 是纹理的平铺模式，它将决定渲染引擎在遇到不在[0, 1]范围内的纹理坐 标时如何进行纹理采样。**

​	在OpenGL里，纹理空间的原点位于左下角，而在DirectX 中，原点位于左上角。幸运的是，Unity在绝大多数情况下（特例情况除外）为我们处理好了这个差异问题，也就是说，即便游戏的目标平台可能既有OpenGL风格的，也有DirectX风格的，但我们在 Unity中使用的通常只有一种坐标系。Unity使用的纹理空间是符合 OpenGL的传统的，也就是说，原点位于纹理左下角。



## 单张纹理

​	我们通常会使用一张纹理来代替物体的漫反射颜色。一般是使用一张纹理取得每个uv映射坐标的纹素值（即颜色值）和自定义的一个颜色做乘积得到的颜色作为漫反射的颜色。如下：

```c
	//使用纹理采样来和合并成漫反射颜色
	fixed3 albedo=tex2D(_MainTex,i.uv).rgb*_Color.rgb;
```





## 纹理属性

在我们向Unity中导入一张纹理资源后，可以在它的材质面板上调整其属性。如下图：

![](../assets/img/resources/improtTexturProperty.jpg)

​	**1、**纹理面板中的第一个属性是纹理类型。在本节中，我们使用的是Texture类型，在下面的法线纹理一节中，我们会使用Normal map类型。而在后面的章节中，我们还会看到Cubemap等高级纹理类型。我们之所以要为导入的纹理选择合适的类型，是因为只有这样才能让Unity知道我们的意图，为Unity Shader传递正确的纹理，并在一些情况下可以让Unity对该纹理进行优化。

​	当把纹理类型设置成Texture后，下面会有一个Alpha from Grayscale复选框，如果勾选了它，那么透明通道的值将会由每个像素的灰度值生成。关于透明效果，我们会在第8章中讲到。在这里我们不需要勾选它。

​	**2、**下面一个属性非常重要——Wrap Mode。它决定了当纹理坐标超过[0, 1]范围后将会如何被平铺。Wrap Mode有两种模式：一种是Repeat，在这种模式下，如果纹理坐标超过了1，那么它的整数部分将会被舍弃，而直接使用小数部分进行采样，这样的结果是纹理将会不断重复；另一种是Clamp，在这种模式下，如果纹理坐标大于1，那么将会截取到1，如果小于0，那么将会截取到0。不同的设置，效果也不相同，如下：

![](../assets/img/resources/wrapModeSetting.jpg)

此图展示了在纹理的平铺（Tiling）属性为(3, 3)时分别使用两种Wrap Mode的结果。左图使用了Repeat模式，在这种模式下纹理将会不断重复；右图使用了Clamp模式，在这种模式下超过范围的部分将会截取到边界值，形成一个条形结构。

​	**3、**纹理导入面板中的下一个属性是Filter Mode属性，它决定了当纹理由于变换而产生拉伸时将会采用哪种滤波模式。Filter Mode支持3种模式：Point，Bilinear以及Trilinear。它们得到的图片滤波效果依次提升，但需要耗费的性能也依次增大。纹理滤波会影响放大或缩小纹理时得到的图片质量。例如，当我们把一张64×64大小的纹理贴在一个512×512大小的平面上时，就需要放大纹理。



























